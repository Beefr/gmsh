\input texinfo.tex @c -*-texinfo-*-
@c $Id: gmsh.texi,v 1.29 2003-04-18 07:53:51 geuzaine Exp $
@c
@c Copyright (C) 1997-2003 C. Geuzaine, J.-F. Remacle
@c
@c This program is free software; you can redistribute it and/or modify
@c it under the terms of the GNU General Public License as published by
@c the Free Software Foundation; either version 2 of the License, or
@c (at your option) any later version.
@c
@c This program is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with this program; if not, write to the Free Software
@c Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
@c USA.
@c 
@c Please report all bugs and problems to "gmsh@geuz.org".
@c
@c =========================================================================
@c
@c This is the Gmsh documentation texinfo source file
@c
@c Things to do -> "Ctrl+s todo:" 
@c
@c Indexing:
@c
@c * @cindex = concept index, e.g. "File formats"
@c * @tindex + @findex = type + function index (= reserved keywords),
@c   e.g. "Spline"
@c
@c Before release, run C-u C-c C-u C-a in GNU Emacs. This updates all node
@c pointers and menus.
@c 
@c =========================================================================
@c
@c For commercial releases, set the COMMERCIAL flag (uncomment the following 
@c line). This will prevent all references to "free software" and the
@c like...
@c
@c @set COMMERCIAL
@c
@c =========================================================================
@c %**start of header
@setfilename        gmsh.info
@set EDITION        1.0
@set GMSH-VERSION   1.44
@set GMSH-WEB       @uref{http://www.geuz.org/gmsh/}
@set COPYRIGHT      @copyright{} 1997-2003 Christophe Geuzaine, Jean-Fran@,{c}ois Remacle
@c
@settitle Gmsh @value{GMSH-VERSION}
@footnotestyle separate
@setchapternewpage odd
@paragraphindent 0
@finalout
@c %**end of header

@c merge function index into type index
@syncodeindex fn tp

@c =========================================================================
@c Info directives
@c =========================================================================

@ifinfo
@dircategory Math
@direntry
* Gmsh: (gmsh).  3D finite element mesh generator with built-in pre- and
post-processing facilities
@end direntry
@noindent
This is edition @value{EDITION} (@today{}) of the @cite{Gmsh Reference
Manual}, for Gmsh @value{GMSH-VERSION}.
@noindent
Copyright @value{COPYRIGHT}
@end ifinfo

@c =========================================================================
@c Title page
@c =========================================================================

@shorttitlepage Gmsh

@titlepage

@title Gmsh Reference Manual

@subtitle The documentation for Gmsh, Version @value{GMSH-VERSION}
@subtitle A finite element mesh generator with built-in pre- and post-processing facilities
@subtitle 
@subtitle Edition @value{EDITION} (@today{})

@author Christophe Geuzaine
@author Jean-Fran@,{c}ois Remacle

@page
@vskip 0pt plus 1filll
Copyright @value{COPYRIGHT}
@sp 1
Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on
all copies.

@end titlepage

@c =========================================================================
@c Table of contents
@c =========================================================================

@summarycontents
@contents

@c =========================================================================
@c Top node (for all output, except TeX)
@c =========================================================================

@ifnottex
@node Top, Copying conditions, (dir), (dir)
@top Gmsh

Christophe Geuzaine and Jean-Fran@,{c}ois Remacle

Gmsh is an automatic 3D finite element mesh generator with build-in pre- and
post-processing facilities. This is edition @value{EDITION} (@today{}) of
the @cite{Gmsh Reference Manual}, for Gmsh @value{GMSH-VERSION}.
@end ifnottex

@c =========================================================================
@c Master menu
@c =========================================================================

@menu
* Copying conditions::          Terms and conditions of use.
* Overview::                    What is Gmsh?
* General tools::               Description of general commands and options.
* Geometry module::             Description of all Geometry commands.
* Mesh module::                 Description of all Mesh commands.
* Solver module::               Description of all Solver commands.
* Post-processing module::      Description of all Post-Processing commands.
* Tutorial::                    A step-by-step tutorial.
* Running Gmsh::                How to run Gmsh on your operating system.
* File formats::                Input and output file formats.
* Programming notes::           Random notes for developers.
* Bugs and versions::           Contact information, version history and list of contributors.
* Tips and tricks::             Some tips to make your life easier with Gmsh.
* GNU General Public License::  Copy of the GNU GPL.
* Concept index::               Index of concepts.
* Syntax index::                Index of reserved keywords in the Gmsh language.

@detailmenu
 --- The Detailed Node Listing ---

Overview

* Geometry::                    
* Mesh::                        
* Solver::                      
* Post-processing::             
* What Gmsh is pretty good at::  
* and what Gmsh is not so good at::  
* Syntactic rules::             
* Comments::                    

General tools

* Expressions::                 
* Operators::                   
* Built-in functions::          
* User-defined functions::      
* Loops and conditionals::      
* General commands::            
* General options::             

Expressions 

* Floating point expressions::  
* Character expressions::       
* Color expressions::           

Geometry module

* Geometry commands::           
* Geometry options::            

Geometry commands

* Points::                      
* Lines::                       
* Surfaces::                    
* Volumes::                     
* Extrusions::                  
* Transformations::             
* Miscellaneous geometry commands::  

Mesh module

* Mesh commands::               
* Mesh options::                

Mesh commands

* Characteristic lengths::      
* Structured grids::            
* Miscellaneous mesh commands::  

Solver module

* Solver options::              

Post-processing module

* Post-processing commands::    
* Post-processing options::     

Tutorial

* t1.geo::                      
* t2.geo::                      
* t3.geo::                      
* t4.geo::                      
* t5.geo::                      
* t6.geo::                      
* t7.geo::                      
* t8.geo::                      
* t9.geo::                      

Running Gmsh

* Interactive vs. non-interactive mode::  
* Command-line options::        
* Mouse actions::               
* Keyboard shortcuts::          

File formats

* Gmsh mesh file format::       
* Gmsh ASCII post-processing file format::  
* Gmsh binary post-processing file format::  
* Gmsh parsed post-processing file format::  
* Gmsh node ordering::          

Bugs, versions and contributors

* Bugs::                        
* Version history::             
* Contributors::                

@end detailmenu
@end menu

@c =========================================================================
@c Copying Conditions
@c =========================================================================

@ifclear COMMERCIAL

@node Copying conditions, Overview, Top, Top
@unnumbered Copying conditions

@cindex Copyright
@cindex Web site
@cindex Internet address
@cindex Download

Gmsh is ``free software''; this means that everyone is free to use it and
to redistribute it on a free basis. Gmsh is not in the public domain; it is
copyrighted and there are restrictions on its distribution, but these
restrictions are designed to permit everything that a good cooperating
citizen would want to do.  What is not allowed is to try to prevent others
from further sharing any version of Gmsh that they might get from you.

Specifically, we want to make sure that you have the right to give away
copies of Gmsh, that you receive source code or else can get it if you want
it, that you can change Gmsh or use pieces of Gmsh in new free programs,
and that you know you can do these things.

To make sure that everyone has such rights, we have to forbid you to deprive
anyone else of these rights.  For example, if you distribute copies of
Gmsh, you must give the recipients all the rights that you have.  You must
make sure that they, too, receive or can get the source code.  And you must
tell them their rights.

Also, for our own protection, we must make certain that everyone finds out
that there is no warranty for Gmsh.  If Gmsh is modified by someone else
and passed on, we want their recipients to know that what they have is not
what we distributed, so that any problems introduced by others will not
reflect on our reputation.

The precise conditions of the license for Gmsh are found in the General
Public License that accompanies the source code (@pxref{GNU General Public
License}). Further information about this license is available from the GNU
Project webpage @uref{http://www.gnu.org/copyleft/gpl-faq.html}.

The source code and various pre-compiled versions of Gmsh (for most of the
classical UNIX platforms, for Windows and for Mac OS) can be downloaded from
the webpage @value{GMSH-WEB}.

If you use Gmsh, we would appreciate that you mention it in your
work. References, as well as the latest news about Gmsh development, are
always available on @value{GMSH-WEB}. Please send all Gmsh-related questions
to the public Gmsh mailing list at @email{gmsh@@geuz.org}.

@end ifclear

@c =========================================================================
@c Overview
@c =========================================================================

@node Overview, General tools, Copying conditions, Top
@chapter Overview

@cindex Introduction
@cindex Overview

Gmsh is an automatic three-dimensional finite element mesh generator,
primarily Delaunay, with built-in pre- and post-processing facilities. Its
primal design goal is to provide a simple meshing tool for academic test
cases with parametric input and up to date visualization capabilities.  One
of its strengths is the ability to respect a characteristic length field for
the generation of adapted meshes on lines, surfaces and volumes, and to mix
these meshes with simple structured (transfinite, extruded, etc.) grids.

Gmsh is built around four modules: geometry, mesh, solver and
post-processing. All geometrical, mesh, solver and post-processing
instructions are prescribed either interactively using the graphical user
interface (GUI) or in ASCII data files using Gmsh's own scripting language.
Interactive actions generate language bits in the input files, and vice
versa. This makes it possible to automate all treatments, using loops,
conditionals and external system calls. A brief description of the four
modules is given hereafter.

@menu
* Geometry::                    
* Mesh::                        
* Solver::                      
* Post-processing::             
* What Gmsh is pretty good at::  
* and what Gmsh is not so good at::  
* Syntactic rules::             
* Comments::                    
@end menu

@c -------------------------------------------------------------------------
@c Geometry: geometrical entity definition
@c -------------------------------------------------------------------------

@node Geometry, Mesh, Overview, Overview
@section Geometry: geometrical entity definition

Geometries are created in a bottom-up flow by successively defining points,
oriented lines (line segments, circles, ellipses, splines,@w{ }@dots{}),
oriented surfaces (plane surfaces, ruled surfaces,@w{ }@dots{}) and
volumes. Compound groups of geometrical entities can be defined, based on
these elementary geometric entities. Gmsh's scripting language allows all
geometrical entities to be fully parameterized.

@c -------------------------------------------------------------------------
@c Mesh: finite element mesh generation
@c -------------------------------------------------------------------------

@node Mesh, Solver, Geometry, Overview
@section Mesh: finite element mesh generation

A finite element mesh is a tessellation of a given subset of the
three-dimensional space by elementary geometrical elements of various shapes
(in Gmsh's case: lines, triangles, quadrangles, tetrahedra, prisms,
hexahedra and pyramids), arranged in such a way that if two of them
intersect, they do so along a face, an edge or a node, and never
otherwise. All the finite element meshes produced by Gmsh are considered as
``unstructured'', even if they were generated in a ``structured'' way
(e.g. by extrusion). This implies that the elementary geometrical elements
are defined only by an ordered list of their vertices but that no predefined
order relation is assumed between any two elements.

The mesh generation is performed in the same bottom-up flow as the geometry
creation: lines are discretized first; the mesh of the lines is then used
to mesh the surfaces; then the mesh of the surfaces is used to mesh the
volumes. This automatically assures the conformity of the mesh when, for
example, two surfaces share a common line. Every meshing step is
constrained by the characteristic length field, which can be uniform,
specified by characteristic lengths associated with elementary geometrical
entities, or associated with another mesh (the background mesh).

For each meshing step, all structured mesh directives are executed first,
and serve as additional constraints for the unstructured parts. The
implemented Delaunay algorithm is subdivided in the following five steps for
surface/volume discretization:

@enumerate
@item
trivial meshing of a box including the convex polygon/polyhedron defined by
the boundary nodes resulting from the discretization of the lines/surfaces;
@item
creation of the initial mesh by insertion of all the nodes on the
lines/surfaces thanks to the Bowyer algorithm;
@item
boundary restoration to force all the edges/faces of the lines/surfaces to
be present in the initial mesh;
@item
suppression of all the unwanted triangles/tetrahedra (in particular those
containing the nodes of the initial box);
@item
insertion of new nodes by the Bowyer algorithm until the characteristic size
of each simplex is lower or equal to the characteristic length field
evaluated at the center of its circumscribed circle/sphere.
@end enumerate

@c -------------------------------------------------------------------------
@c Solver: external solver interface
@c -------------------------------------------------------------------------

@node Solver, Post-processing, Mesh, Overview
@section Solver: external solver interface

External solvers can be interfaced with Gmsh through Unix sockets, which
permits to easily launch external computations and to collect and exploit
the simulation results within Gmsh's post-processing module. The default
solver interfaced with Gmsh is GetDP
(@uref{http://www.geuz.org/getdp/}).

@c -------------------------------------------------------------------------
@c Post-processing: scalar, vector and tensor field visualization
@c -------------------------------------------------------------------------

@node Post-processing, What Gmsh is pretty good at, Solver, Overview
@section Post-processing: scalar, vector and tensor field visualization

Multiple post-processing scalar, vector or tensor maps can be loaded and
manipulated (globally or individually) along with the geometry and the
mesh. Scalar fields are represented by iso-value lines/surfaces or color
maps, while vector and tensor fields are represented by three-dimensional
arrows or displacement maps. Post-processing functions include arbitrary
section computation, offset, elevation, boundary extraction, color map and
range modification, animation, vector graphic output, etc. All
post-processing options can be accessed either interactively or through the
input ASCII text files. Scripting permits to automate all post-processing
operations, e.g. for the creation of animations. User-defined operations can
also be performed on post-processing views through dynamically loadable
plugins.

@c -------------------------------------------------------------------------
@c What Gmsh is pretty good at...
@c -------------------------------------------------------------------------

@node What Gmsh is pretty good at, and what Gmsh is not so good at, Post-processing, Overview
@section What Gmsh is pretty good at @dots{}

Gmsh is a (relatively) small program, and was principally developed ``in
academia, to solve academic problems''@dots{} Nevertheless, over the
years, many people outside universities have found Gmsh useful in their
day-to-day jobs. Here is a tentative list of what Gmsh does best:

@itemize @bullet
@item
quickly describe simple and/or ``repetitive'' geometries, thanks to
user-defined functions, loops, conditionals and includes (see
@ref{User-defined functions}, @ref{Loops and conditionals}, and @ref{General
commands});
@item
parameterize these geometries. Gmsh's scripting language enables all
commands and command arguments to depend on previous calculations (see
@ref{Expressions}, and @ref{Geometry commands});
@item
generate 1D, 2D and 3D simplicial (i.e. using line segments, triangles and
tetrahedra) finite element meshes. The performance of the 1D and 2D
algorithms is pretty good; the 3D algorithm is still somewhat experimental
and slow (see @ref{Mesh module}, and @ref{Tutorial});
@item
specify target element sizes accurately. Gmsh provides several mechanisms to
control the size of the elements in the final mesh: through interpolation
from geometrical point characteristic lengths or geometrical attractors, or
from user-defined background meshes (@pxref{Mesh commands});
@item
create simple extruded geometries and meshes (see @ref{Geometry commands}
and @ref{Mesh commands});
@item
interact with external solvers. Gmsh provides C/C++ and Perl interfaces, and
others can be easily added (@pxref{Solver});
@item
visualize computational results in a great variety of ways. Gmsh can display
scalar, vector and tensor data sets, and can perform various operations on
the resulting post-processing views (@pxref{Post-processing});
@item
export plots in many different formats: vector PostScript or encapsulated
PostScript, LaTeX, PNG, JPEG,@w{ }@dots{} (@pxref{General options});
@item
generate complex animations (see @ref{General tools}, and @ref{t8.geo});
@item
run on low end machines and/or machines with no graphic system. Gmsh can be
compiled with or without the graphical user interface, and all versions can
be used either interactively or not, directly from the command line
(@pxref{Running Gmsh});
@item
configure your preferred options. Gmsh has a large number of configuration
options that can be set interactively using the GUI, scattered inside
command files, changed on the fly in scripts, set in per-user configuration
files, or specified on the command-line (see @ref{General options},
@ref{Geometry options}, @ref{Mesh options}, @ref{Post-processing options},
and @ref{Running Gmsh});
@item
and do all the above on various platforms (Windows, Mac and Unix), for free
(@pxref{Copying conditions}), using clear-text ASCII files and/or a small
but powerful graphical user interface.
@end itemize

@c -------------------------------------------------------------------------
@c ... and what Gmsh is not so good at
@c -------------------------------------------------------------------------

@node and what Gmsh is not so good at, Syntactic rules, What Gmsh is pretty good at, Overview
@section @dots{} and what Gmsh is not so good at

Due to its historical background and limited developer manpower, Gmsh has
also some (a lot of?) weaknesses:

@itemize @bullet
@item
the bottom-up approach for describing geometries can become impractical for
complex models;
@item
there is no support for NURBS and only very limited support for trimmed
surfaces;
@item
Gmsh is not primarily a structured mesh generator: no automatic
quadrilateral or hexahedral meshing algorithm is provided. If you want
quadrangles, you have to use transfinite or extruded meshes or recombine
unstructured triangular meshes. For hexahedra, your only choice is
transfinite or extruded meshes;
@item
Gmsh is not a multi-bloc generator: all meshes produced by Gmsh are
conforming in the sense of finite element meshes;
@item
there is not support for curved mesh elements as of this writing (Gmsh
1.44);
@item
Gmsh was designed to solve academic test-cases, not industrial-size
problems. You may find that Gmsh is too slow for large problems (with
thousands of geometric primitives, or millions of mesh/post-processing
elements).
@end itemize

If you have the skills and some free time, feel free to join the project! We
gladly accept any code contributions (@pxref{Programming notes}) to remedy
the aforementioned (and all other) shortcommings...

@c -------------------------------------------------------------------------
@c Syntactic Rules Used in this Document
@c -------------------------------------------------------------------------

@node Syntactic rules, Comments, and what Gmsh is not so good at, Overview
@section Syntactic rules used in this document

@cindex Syntax, rules
@cindex Rules, syntactic
@cindex Document syntax

Here are the rules we tried to follow when writing this user's guide. Note
that metasyntactic variable definitions stay valid throughout the manual
(and not only in the sections where the definitions appear).

@enumerate
@item 
Keywords and literal symbols are printed like @code{this}.
@item 
Metasyntactic variables (i.e.@: text bits that are not part of the syntax,
but stand for other text bits) are printed like @var{this}.
@item 
A colon (@code{:}) after a metasyntactic variable separates the variable
from its definition.
@item 
Optional rules are enclosed in @code{<} @code{>} pairs.
@item 
Multiple choices are separated by @code{|}.
@item 
Three dots (@dots{}) indicate a possible repetition of the preceding rule.
@end enumerate

@c -------------------------------------------------------------------------
@c Comments
@c -------------------------------------------------------------------------

@node Comments,  , Syntactic rules, Overview
@section Comments

@cindex Comments
@cindex File, comment

@findex /*, */
@findex //

All Gmsh ASCII text input files support both C and C++ style comments:

@enumerate
@item
any text comprised between @code{/*} and @code{*/} pairs is ignored;
@item
the rest of a line after a double slash @code{//} is ignored.
@end enumerate

These commands won't have the described effects inside double quotes or
inside keywords. Also note that `white space' (spaces, tabs, new line
characters) is ignored inside all expressions.

@c =========================================================================
@c General tools
@c =========================================================================

@node General tools, Geometry module, Overview, Top
@chapter General tools

This chapter describes the general commands and options that can be used in
Gmsh's ASCII text input files. By ``general'', we mean ``not specifically
related to one of the geometry, mesh, solver or post-processing
modules''. Commands peculiar to these modules will be introduced in
@ref{Geometry module}, @ref{Mesh module}, @ref{Solver module}, and
@ref{Post-processing module}, respectively.

Note that, if you are just beginning to use Gmsh, or just want to see what
Gmsh is all about, you really don't need to read this chapter and the four
next ones. Just have a quick look at @ref{Running Gmsh}, and go play with
the graphical user interface, running the tutorials and demonstration files
bundled in the distribution! Most of the commands and options described in
the following chapters are available interactively in the GUI, so you don't
need to worry about Gmsh's internals for creating your first geometries,
meshes and post-processing plots. Once you master the tutorial (read the
source files: they are heavily commented---see @ref{Tutorial}), you might
want to come back here to learn more about the specific syntax of Gmsh's
commands and esoteric options.

@menu
* Expressions::                 
* Operators::                   
* Built-in functions::          
* User-defined functions::      
* Loops and conditionals::      
* General commands::            
* General options::             
@end menu

@c -------------------------------------------------------------------------
@c Expressions
@c -------------------------------------------------------------------------

@node Expressions, Operators, General tools, General tools
@section Expressions 

@cindex Expression, definition
@cindex Constant, definition

The two constant types used in Gmsh are @var{real} and @var{string} (there
is no integer type).  These types have the same meaning and syntax as in the
C or C++ programming languages.  

@menu
* Floating point expressions::  
* Character expressions::       
* Color expressions::           
@end menu

@c .........................................................................
@c Floating point expressions
@c .........................................................................

@node Floating point expressions, Character expressions, Expressions, Expressions
@subsection Floating point expressions

@cindex Expression, floating point
@cindex Real numbers
@cindex Numbers, real
@cindex Floating point numbers

Floating point expressions (or, more simply, ``expressions'') are denoted by
the metasyntactic variable @var{expression} (remember the definition of the
syntactic rules in @ref{Syntactic rules}), and are evaluated during the
parsing of the data file:

@example
@var{expression}:
  @var{real} |
  @var{expression-id} |
  @var{expression-id} [ @var{expression} ] |
  @var{operator-unary} @var{expression} |
  @var{expression} @var{operator-binary} @var{expression} |
  @var{expression} @var{operator-ternary-left} @var{expression} @var{operator-ternary-right} @var{expression} |
  @var{built-in-function} |
  @var{real-option}
@end example

Such @w{@var{expression}s} are used in most of Gmsh's commands. The
operators @var{operator-unary}, @var{operator-binary} and
@var{operator-ternary-left}/@var{operator-ternary-right} are defined in
@ref{Operators}. For the definition of @w{@var{built-in-function}s}, see
@ref{Built-in functions}.

@cindex Expression, lists
@cindex Number, lists

List of expressions are also widely used, and are defined as:

@example
@var{expression-list}:
  @var{expression-list-item} <, @var{expression-list-item}> @dots{}
@end example

@noindent with

@example
@var{expression-list-item}:
  @var{expression} |
  @var{expression} : @var{expression} |
  @var{expression} : @var{expression} : @var{expression} |
  @var{expression-id} [ ] |
  @var{expression-id} [ @{ @var{expression-list} @} ]
@end example

The second case in this last definition permits to create a list containing
the range of numbers comprised between two @w{@var{expression}s}, with a
unit incrementation step. The third case also permits to create a list
containing the range of numbers comprised between two @w{@var{expression}s},
but with a positive or negative incrementation step equal to the third
@var{expression}. The fourth case permits to reference an expression list.
The last case permits to reference an expression sublist (whose elements are
those corresponding to the indices provided by the
@var{expression-list}). To see the practical use of such expressions, have a
look at the first couple of examples in @ref{Tutorial}.

In order to lighten the syntax, you can always ommit the braces @code{@{@}}
enclosing an @var{expression-list} if this @var{expression-list} contains a
single item.

@cindex Expression, affectation
@cindex Expression, identifier

@findex =
@findex +=
@findex -=
@findex *=
@findex /=

The syntax for the definition of a new expression identifier is twofold,
depending on the nature of the right hand side (being a single
@var{expression} or a list):

@example
@var{expression-id} = @var{expression};
@var{expression-id} [ ] = @{ @var{expression-list} @};
@end example

@noindent with

@example
@var{expression-id}:
  @var{string} |
  @var{real-option}
@end example

The various @w{@var{real-option}s} are listed in @ref{General options},
@ref{Geometry options}, @ref{Mesh options}, @ref{Solver options}, and
@ref{Post-processing options}. In addition to the @w{@var{real-option}s},
eight @w{@var{expression-id}s} are predefined (hard coded in Gmsh's parser):
@ftable @code
@item Pi
Returns 3.1415926535897932.

@item MPI_Size
Returns the number of processors on which Gmsh is running (always 1, except
if you compiled Gmsh's parallel extensions).

@item MPI_Rank
Returns the rank of the current processor.

@item newp
Returns the next available point number. As we will see in @ref{Geometry
module}, a unique number is associated with every geometrical point:
@code{newp} permits to know the highest number already attributed. This is
mostly useful when writing user-defined functions (@pxref{User-defined
functions}) or general geometric primitives, when one does not know a priori
which numbers are already attributed, and which ones are still available.

@item newl
Returns the next available line number.

@item news
Returns the next available surface number.

@item newv
Returns the next available volume number.

@item newreg
Returns the next available region number. That is, @code{newreg} returns the
maximum of @code{newp}, @code{newc}, @code{news}, @code{newv} and all
physical entity numbers@footnote{For compatibility purposes, the behavior
of @code{newc}, @code{news}, @code{newv} and @code{newreg} can be modified
with the @code{Geometry.OldNewReg} option (@pxref{Geometry options}).}.
@end ftable

One can also perform additions, subtractions, multiplications and divisions
while affecting a value to an existing @var{expression-id}, using:

@example
@var{expression-id} += @var{expression};
@var{expression-id} -= @var{expression};
@var{expression-id} *= @var{expression};
@var{expression-id} /= @var{expression};
@end example

@noindent for single expressions, and 

@example
@var{expression-id} [ @{ @var{expression-list} @} ] = @{ @var{expression-list} @};
@var{expression-id} [ @{ @var{expression-list} @} ] += @{ @var{expression-list} @};
@var{expression-id} [ @{ @var{expression-list} @} ] -= @{ @var{expression-list} @};
@var{expression-id} [ @{ @var{expression-list} @} ] *= @{ @var{expression-list} @};
@var{expression-id} [ @{ @var{expression-list} @} ] /= @{ @var{expression-list} @};
@end example

@noindent for lists of expressions@footnote{Remember the remark made when
defining @w{@var{expression-list}s}: the braces enclosing the
@var{expression-list} are optional if the @var{expression-list} only
contains a single item.}, in which case the affectations are done ``list
item per list item''.

@c .........................................................................
@c Character expressions
@c .........................................................................

@node Character expressions, Color expressions, Floating point expressions, Expressions
@subsection Character expressions

@cindex Expression, character
@cindex Strings

Character expressions are defined as:

@example
@var{expression-char}:
  "@var{string}" |
  StrPrefix ( @var{expression-char} ) |
  StrCat ( @var{expression-char} , @var{expression-char} ) |
  Sprintf ( @var{expression-char} , @var{expression-list} ) |
  @var{string-option}
@end example

@noindent The second case in this definition permits to take the
prefix of a string (e.g. for removing the extension from a file name). The
third case permits to concatenate two character expressions, and the fourth
is an equivalent of the @code{sprintf} C function (where
@var{expression-char} is a format string that can contain floating point
formatting characters: @code{%e}, @code{%g}, etc.).

Character expressions are mostly used to specify non-numeric options and
input/output file names. See @ref{t8.geo}, for an interesting usage of
@w{@var{expression-char}s} in an animation script. Although there exists no
character expression identifier, @w{@var{expression-char}s} can be affected
to @w{@var{string-option}s}:

@example
@var{string-option} = @var{expression-char};
@end example

The various @w{@var{string-option}s} are listed in @ref{General options},
@ref{Geometry options}, @ref{Mesh options}, @ref{Solver options}, and
@ref{Post-processing options}.

@c .........................................................................
@c Color expressions
@c .........................................................................

@node Color expressions,  , Character expressions, Expressions
@subsection Color expressions

@cindex Expression, color
@cindex Colors

Colors expressions are hybrids between fixed-length braced
@w{@var{expression-list}s} and @w{@var{string}s}:

@example
@var{expression-color}:
  @var{string} |
  @{ @var{expression}, @var{expression}, @var{expression} @} |
  @{ @var{expression}, @var{expression}, @var{expression}, @var{expression} @} |
  @var{color-option}
@end example

@noindent The first case permits to use the X Windows names to refer to colors,
e.g., @code{Red}, @code{SpringGreen}, @code{LavenderBlush3},@w{ }@dots{}
(see @file{Common/Colors.h} in Gmsh's source tree). The second case permits
to define colors by using three expressions to specify their red, green and
blue components (with values comprised between 0 and 255). The third case
permits to define colors by using the red, green and blue color components
as well as the alpha channel. See @ref{t3.geo}, for an example of the use of
color expressions.

Although there exists no color expression identifier,
@w{@var{expression-color}s} can be affected to @w{@var{color-option}s}:

@example
@var{color-option} = @var{expression-color};
@end example

The various @w{@var{color-option}s} are listed in @ref{General options},
@ref{Geometry options}, @ref{Mesh options}, @ref{Solver options}, and
@ref{Post-processing options}.

@c -------------------------------------------------------------------------
@c Operators
@c -------------------------------------------------------------------------

@node Operators, Built-in functions, Expressions, General tools
@section Operators

@cindex Operators, definition
@cindex Unary operators
@cindex Binary operators
@cindex Ternary operators

Gmsh's operators are similar to the corresponding operators in C and
C++. Here is the list of the unary, binary and ternary operators currently
implemented.

@noindent
@var{operator-unary}:
@ftable @code
@item -
Unary minus.
@item !
Logical not.
@item ++
Post-incrementation. (Pre-incrementation is not supported.)
@item --
Post-decrementation. (Pre-decrementation is not supported.)
@end ftable

@noindent
@var{operator-binary}:
@ftable @code
@item ^
Exponentiation.
@item *
Multiplication. 
@item /
Division.
@item %
Modulo.
@item +
Addition.
@item -
Subtraction.
@item ==
Equality.
@item !=
Inequality.
@item >
Greater.
@item >=
Greater or equality.
@item <
Less.
@item <=
Less or equality.
@item &&
Logical `and'.
@item ||
Logical `or'. (Warning: the logical `or' always implies the evaluation of
both arguments.  That is, unlike in C or C++, the second operand of
@code{||} is evaluated even if the first one is true).
@end ftable

@noindent
@var{operator-ternary-left}:
@ftable @code
@item ?
@end ftable
@var{operator-ternary-right}:
@ftable @code
@item :
The only ternary operator, formed by @var{operator-ternary-left} and
@var{operator-ternary-right}, returns the value of its second argument if
the first argument is non-zero; otherwise it returns the value of its third
argument.
@end ftable

@cindex Evaluation, order
@cindex Order of evaluation
@cindex Operation, priorities
@cindex Priorities, operations

@findex ()

The evaluation priorities are summarized below (from stronger to weaker,
i.e.@: @code{*} has a highest evaluation priority than
@code{+}). Parentheses @code{()} may be used anywhere to change the order of
evaluation:

@enumerate
@item @code{()}
@item @code{^}
@item @code{!}, @code{++}, @code{--}, @code{-} (unary)
@item @code{*}, @code{/}, @code{%}
@item @code{+}, @code{-}
@item @code{<}, @code{<=}, @code{>}, @code{>=}
@item @code{==}, @code{!=}
@item @code{&&}
@item @code{||}
@item @code{?:}
@item @code{=}, @code{+=}, @code{-=}, @code{*=}, @code{/=}
@end enumerate


@c -------------------------------------------------------------------------
@c Built-in functions
@c -------------------------------------------------------------------------

@node Built-in functions, User-defined functions, Operators, General tools
@section Built-in functions

@cindex Functions, built-in

A built-in function is composed of an identifier followed by a pair of
parentheses containing an @var{expression-list} (the list of its
arguments)@footnote{For compatibility with GetDP
(@uref{http://www.geuz.org/getdp/}), parentheses can be replaced by brackets
@code{[]}.}. Here is the list of the built-in functions currently
implemented:

@noindent
@var{build-in-function}:

@ftable @code
@item Acos ( @var{expression} )
Arc cosine (inverse cosine) of an @var{expression} in [-1,1]. Returns a value
in [0,Pi]. 

@item Asin ( @var{expression} )
Arc sine (inverse sine) of an @var{expression} in [-1,1]. Returns a value in
[-Pi/2,Pi/2].

@item Atan ( @var{expression} )
Arc tangent (inverse tangent) of @var{expression}. Returns a value in
[-Pi/2,Pi/2].

@item Atan2 ( @var{expression}, @var{expression} )
Arc tangent (inverse tangent) of the first @var{expression} divided by the
second. Returns a value in [-Pi,Pi].

@item Ceil ( @var{expression} )
Rounds @var{expression} up to the nearest integer.

@item Cos ( @var{expression} )
Cosine of @var{expression}.

@item Cosh ( @var{expression} )
Hyperbolic cosine of @var{expression}.

@item Exp ( @var{expression} )
Returns the value of e (the base of natural logarithms) raised to the power
of @var{expression}.

@item Fabs ( @var{expression} )
Absolute value of @var{expression}.

@item Fmod ( @var{expression}, @var{expression} )
Remainder of the division of the first @var{expression} by the second, with
the sign of the first.

@item Floor ( @var{expression} )
Rounds @var{expression} down to the nearest integer.

@item Hypot ( @var{expression}, @var{expression} )
Returns the square root of the sum of the square of its two arguments.

@item Log ( @var{expression} )
Natural logarithm of @var{expression} (@var{expression} > 0).

@item Log10 ( @var{expression} )
Base 10 logarithm of @var{expression} (@var{expression} > 0).

@item Modulo ( @var{expression}, @var{expression} )
see @code{Fmod( @var{expression}, @var{expression} )}.

@item Rand ( @var{expression} )
Random number between zero and @var{expression}.

@item Sqrt ( @var{expression} )
Square root of @var{expression} (@var{expression} >= 0).

@item Sin ( @var{expression} )
Sine of @var{expression}.

@item Sinh ( @var{expression} )
Hyperbolic sine of @var{expression}.

@item Tan ( @var{expression} )
Tangent of @var{expression}.

@item Tanh ( @var{expression} )
Hyperbolic tangent of @var{expression}.
@end ftable

@c -------------------------------------------------------------------------
@c User-defined functions
@c -------------------------------------------------------------------------

@node User-defined functions, Loops and conditionals, Built-in functions, General tools
@section User-defined functions

@cindex Function, user-defined

User-defined functions take no arguments, and are evaluated as if a file
containing the function body was included at the location of the @code{Call}
statement.

@ftable @code
@item Function @var{string}
Begins the declaration of a user-defined function named @var{string}. The
body of the function starts on the line after `@code{Function
@var{string}}', and can contain any Gmsh command.

@item Return
Ends the body of the current user-defined function. Function declarations
cannot be imbricated.

@item Call @var{string};
Executes the body of a (previously defined) function named @var{string}.
@end ftable

@xref{t5.geo}, for an example of a user-defined function.

@c -------------------------------------------------------------------------
@c Loops and conditionals
@c -------------------------------------------------------------------------

@node Loops and conditionals, General commands, User-defined functions, General tools
@section Loops and conditionals

Loops and conditionals are defined as follows, and can be imbricated:

@ftable @code
@item For ( @var{expression} : @var{expression} )
Iterates from the value of the first @var{expression} to the value of the
second @var{expression}, with a unit incrementation step. At each iteration,
the commands comprised between the @code{For} and the matching @code{EndFor}
tags are executed.

@item For ( @var{expression} : @var{expression} : @var{expression} )
Iterates from the value of the first @var{expression} to the value of the
second @var{expression}, with a positive or negative incrementation step
equal to the third @var{expression}. At each iteration, the commands
comprised between the @code{For} and the matching @code{EndFor} tags are
executed.

@item For @var{string} In ( @var{expression} : @var{expression} )
Iterates from the value of the first @var{expression} to the value of the
second @var{expression}, with a unit incrementation step. At each iteration,
the value of the iterate is affected to an expression named @var{string},
and the commands comprised between the @code{For} and the matching
@code{EndFor} tags are executed.

@item For @var{string} In ( @var{expression} : @var{expression} : @var{expression} )
Iterates from the value of the first @var{expression} to the value of the
second @var{expression}, with a positive or negative incrementation step
equal to the third @var{expression}. At each iteration, the value of the
iterate is affected to an expression named @var{string}, and the commands
comprised between the @code{For} and the matching @code{EndFor} tags are
executed.

@item EndFor
Ends a matching @code{For} command.

@item If ( @var{expression} )
The body enclosed between `@code{If ( @var{expression} )}' and the matching
@code{Endif} is evaluated if @var{expression} is non-zero.

@item EndIf
Ends a matching @code{If} command.
@end ftable

@xref{t5.geo}, for an example of @code{For} and @code{If} commands. Gmsh
does not provide any @code{Else} (or similar) command at the time of this
writing (Gmsh 1.44).

@c -------------------------------------------------------------------------
@c General commands
@c -------------------------------------------------------------------------

@node General commands, General options, Loops and conditionals, General tools
@section General commands

The following commands can be used anywhere in a Gmsh ASCII text input file:

@ftable @code
@item Exit;
Aborts the current script.

@item Printf ( @var{expression-char} , @var{expression-list} );
Prints a character expression in the information window and/or on the
terminal. @code{Printf} is equivalent to the @code{printf} C function:
@var{expression-char} is a format string that can contain formatting
characters (@code{%f}, @code{%e}, etc.). Note that all @w{@var{expression}s}
are evaluated as floating point values in Gmsh (@pxref{Expressions}), so
that only valid floating point formatting characters make sense in
@var{expression-char}. @xref{t5.geo}, for an example of the use of
@code{Printf}.

@item Merge @var{expression-char};
Merges a file named @var{expression-char}. This command is equivalent to the
`File->Merge' menu in the graphical user interface. If the path in
@var{expression-char} is not absolute, @var{expression-char} is appended to
the directory where the current opened project resides.

@item MergeWithBoundingBox @var{expression-char};
Merges a file and forces the recalculation of the scene's bounding box.

@item Draw;
Redraws the scene.

@item Save @var{expression-char};
Saves the mesh in a file named @var{expression-char}, using the current
@code{Mesh.Format} (@pxref{Mesh options}).

@item Print @var{expression-char};
Prints the graphic window in a file named @var{expression-char}, using the
current @code{Print.Format} (@pxref{General options}).

@item Sleep @var{expression};
Suspends the execution of Gmsh during @var{expression} seconds.

@item System @var{expression-char};
Executes a system call.

@item Include @var{expression-char};
@item #include @var{expression-char};
Includes the file named @var{expression-char} at the current position in the
input file. Both include commands should be given on a line of their own.
@end ftable

@c -------------------------------------------------------------------------
@c General options
@c -------------------------------------------------------------------------

@node General options,  , General commands, General tools
@section General options

Here is the list of the general @w{@var{string-option}s},
@w{@var{real-option}s} and @w{@var{color-option}s} (in that order---check
the default values to see the types). Most of these options are accessible
in the graphical user interface, but not all of them. When running Gmsh
interactively, changing an option in the ASCII text input file will modify
the option in the GUI in real time. This permits for example to resize the
graphical window in a script, or to interact with animations in the script
and in the GUI at the same time.

Gmsh's default behavior is to save some of these options in a per-user
``session resource'' file (@code{General.SessionFileName}) each time Gmsh is
shut down. This permits for example to automatically remember the size and
location of the windows or which fonts to use. Other options can be saved in
a per-user ``option'' file (@code{General.OptionsFileName}), automatically
loaded by Gmsh during startup, by using the `Tools->Options->Save' menu. 

@c All the opt_XXX.texi files are generated automatically with `gmsh -doc'

@include opt_general.texi

@include opt_print.texi

@c =========================================================================
@c Geometry module
@c =========================================================================

@node Geometry module, Mesh module, General tools, Top
@chapter Geometry module

@cindex Geometry
@cindex Module, Geometry

Gmsh's geometry module provides a simple CAD engine, using a bottom-up
approach: you need to first define points (using the @code{Point} command:
see below), then lines (using @code{Line}, @code{Circle}, @code{Spline},@w{
}@dots{}, commands or by extruding points), then surfaces (using for example
the @code{Plane Surface} or @code{RuledPlane Surface} commands, or by
extruding lines), and finally volumes (using the @code{Volume} command or by
extruding surfaces).

These geometrical entities are called ``elementary'' in Gmsh's jargon, and
are assigned identification numbers when they are created:
@enumerate
@item each elementary point must possess a unique identification number;
@item each elementary line must possess a unique identification number;
@item each elementary surface must possess a unique identification number;
@item each elementary volume must possess a unique identification number.
@end enumerate
Elementary geometrical entities can be manipulated in various ways, using
the @code{Translate}, @code{Rotate}, @code{Scale} or @code{Symmetry}
commands.

Compound groups of elementary geometrical entities can also be defined and
are called ``physical'' entities. These physical entities cannot be modified
by geometry commands: their only purpose is to assemble elementary entities
into larger groups, possibly modifying their orientation, so that they can
be referred to by the mesh module as single entities. Each physical entity
is assigned a unique identification number when it is created. That is, no
two physical entities (even of different type, like a physical line and a
physical surface) can share identical identification numbers. @xref{Mesh
module}, for more information about how physical entites affect the way
meshes are saved.

@menu
* Geometry commands::           
* Geometry options::            
@end menu

@c -------------------------------------------------------------------------
@c Geometry commands
@c -------------------------------------------------------------------------

@node Geometry commands, Geometry options, Geometry module, Geometry module
@section Geometry commands

The next subsections describe all the available geometry commands. These
commands can be used anywhere in a Gmsh ASCII text input file. Note that the
following general syntax rule is applied for the definition of geometrical
entities: ``If a number defines a new entity, it is enclosed between
parentheses. If a number refers to a previously defined entity, it is
enclosed between braces.''

@menu
* Points::                      
* Lines::                       
* Surfaces::                    
* Volumes::                     
* Extrusions::                  
* Transformations::             
* Miscellaneous geometry commands::  
@end menu

@c .........................................................................
@c Points
@c .........................................................................

@node Points, Lines, Geometry commands, Geometry commands
@subsection Points

@ftable @code
@item Point ( @var{expression} ) = @{ @var{expression}, @var{expression}, @var{expression}, @var{expression} @};
Creates an elementary point. The @var{expression} inside the parentheses is
the point number; the three first @w{@var{expression}s} inside the braces on
the right hand side give the three X, Y and Z coordinates of the point in
the three-dimensional Euclidean space; the last @var{expression} sets the
characteristic mesh length at that point. @xref{Mesh module}, for more
information about how this characteristic length indormation is used in the
meshing process.

@item Physical Point ( @var{expression} ) = @{ @var{expression-list} @};
Creates a physical point. The @var{expression} inside the parentheses is the
physical point number; the @var{expression-list} on the right hand side
should contain the numbers of all the elementary points that you want to
group into the physical point.
@end ftable

@c .........................................................................
@c Lines
@c .........................................................................

@node Lines, Surfaces, Points, Geometry commands
@subsection Lines

@ftable @code
@item Bezier ( @var{expression} ) = @{ @var{expression-list} @};
Creates a Bezier curve. The @var{expression} inside the parentheses is
the Bezier curve number; the @var{expression-list} on the right hand side
should contain the numbers of all the curve's control points.

@item BSpline ( @var{expression} ) = @{ @var{expression-list} @};
Creates a B-spline curve. The @var{expression} inside the parentheses is the
B-spline curve number; the @var{expression-list} on the right hand side
should contain the numbers of all the B-spline's control points. Repeated
control points have the expected effect.

@item Circle ( @var{expression} ) = @{ @var{expression}, @var{expression}, @var{expression} @};
Creates a circle arc (strictly) smaller than Pi. The @var{expression} inside
the parentheses is the circle arc number; the first @var{expression} inside
the braces on the right hand side gives the number of the start point of the
arc; the second @var{expression} gives the point number of the center of the
circle; the last @var{expression} gives the number of the end point of the
arc.

@c todo:
@c @item Circle ( @var{expression} ) = @{ @var{expression}, @var{expression}, @var{expression} @} Plane @{ @var{expression}, @var{expression}, @var{expression} @};

@item CatmullRom ( @var{expression} ) = @{ @var{expression-list} @};
@code{CatmullRom} is a synonym for @code{Spline}.

@item Ellipse ( @var{expression} ) = @{ @var{expression}, @var{expression}, @var{expression}, @var{expression} @};
Creates an ellipse arc. The @var{expression} inside the parentheses is the
ellispe arc number; the first @var{expression} inside the braces on the
right hand side gives the number of the start point of the arc; the second
@var{expression} gives the point number of the center of the ellipse; the
third @var{expression} gives the number of any point located on the major
axis of the ellipse; the last @var{expression} gives the number of the end
point of the arc.  (A deprecated synonym for @code{Ellipse} is
@code{Ellispis}.)

@item Line ( @var{expression} ) = @{ @var{expression}, @var{expression} @};
Creates a straight line segment. The @var{expression} inside the parentheses
is the line segment number; the two @w{@var{expression}s} inside the braces
on the right hand side give the start and end point numbers of the segment.
@c todo: multi-lines not authorized yet

@item Line Loop ( @var{expression} ) = @{ @var{expression-list} @};
Creates an oriented line loop. The @var{expression} inside the parentheses
is the line loop number; the @var{expression-list} on the right hand side
should contain the numbers of all the elementary lines that constitute the
line loop. A line loop must be a closed loop, and the elementary lines
should be ordered and oriented (using a negative line number to specify
reverse orientation). If the orientation is correct, but the ordering is
wrong, Gmsh will actually reorder the list internally to create a consistent
loop. Although Gmsh supports it, it is not recommened to specify multiple
line loops (or subloops) in a single @code{Line Loop} command. (Line loops
are used to create surfaces: see @ref{Surfaces}.)

@c todo:
@c @item Nurbs ( @var{expression} ) = @{ @var{expression-list} @};

@c todo: @item Parametric ( @var{expression} ) = @{ @var{expression}, @var{expression}, "@var{string}", "@var{string}", "@var{string}" @};

@item Physical Line ( @var{expression} ) = @{ @var{expression-list} @};
Creates a physical line. The @var{expression} inside the parentheses is the
physical line number; the @var{expression-list} on the right hand side
should contain the numbers of all the elementary lines that you want to
group into the physical line. Specifying negative numbers in the
@var{expression-list} will reverse the orientation of the mesh elements in
the saved mesh output file.

@item Spline ( @var{expression} ) = @{ @var{expression-list} @};
Creates a spline curve. The @var{expression} inside the parentheses is the
spline number; the @var{expression-list} on the right hand side should
contain the numbers of all the spline's control points.
@end ftable

@c .........................................................................
@c Surfaces
@c .........................................................................

@node Surfaces, Volumes, Lines, Geometry commands
@subsection Surfaces

@ftable @code
@c todo: @item Nurbs Surface ( @var{expression} ) = @{ @var{expression-list-list} @} Knots @{ @{ @var{expression-list} @}, @{ @var{expression-list} @} @} Order @{ @var{expression}, @var{expression} @};

@c todo: @item Nurbs Surface With Bounds ( @var{expression} ) = @{ @var{expression-list-list} @} Knots @{ @{ @var{expression-list} @}, @{ @var{expression-list} @} @} Order @{ @var{expression}, @var{expression} @};

@item Plane Surface ( @var{expression} ) = @{ @var{expression-list} @};
Creates a plane surface. The @var{expression} inside the parentheses is the
plane surface number; the @var{expression-list} on the right hand side
should contain the numbers of all the line loops defining the surface. The
first line loop defines the exterior boundary of the surface; all other line
loops define holes in the surface.

@item Ruled Surface ( @var{expression} ) = @{ @var{expression} @};
Creates a ruled surface, i.e. a surface that can be interpolated using
transfinite interpolation. The @var{expression} inside the parentheses is
the ruled surface number; the @var{expression} on the right hand side should
a single line loop, composed of either three or four elementary lines.

@item Surface Loop ( @var{expression} ) = @{ @var{expression-list} @};
Creates a surface loop (a shell). The @var{expression} inside the
parentheses is the surface loop number; the @var{expression-list} on the
right hand side should contain the nubers of all the elementary surfaces
that constitute the surface loop. A surface loop must always represent a
closed shell, and the elementary surfaces should be oriented consistently
(using a negative surface number to specify reverse orientation). (Surface
loops are used to create volumes: see @ref{Volumes}.)

@c todo: @item Triangulation Surface ( @var{expression} ) = ( @var{expression}, @var{expression} ) @{ @var{expression-list} @} @{ @var{expression-list} @};

@c todo: @item Trimmed Surface ( @var{expression} ) = @{ @var{expression}, @{ @var{expression-list} @} @};
@end ftable

@c .........................................................................
@c Volumes
@c .........................................................................

@node Volumes, Extrusions, Surfaces, Geometry commands
@subsection Volumes

@ftable @code
@item Volume ( @var{expression} ) = @{ @var{expression-list} @};
Creates a volume. The @var{expression} inside the parentheses is the volume
number; the @var{expression-list} on the right hand side should contain the
numbers of all the surface loops defining the volume. The first surface loop
defines the exterior boundary of the volume; all other surface loops define
holes in the volume. (A deprecated synonym for @code{Volume} is
@code{Complex Volume}.)
@end ftable

@c .........................................................................
@c Extrusions
@c .........................................................................

@node Extrusions, Transformations, Volumes, Geometry commands
@subsection Extrusions

Lines, surfaces and volumes can also be created through extrusion of points,
lines and surfaces, respectively. Here is the syntax of the geometrical
extrusion commands (go to @ref{Structured grids} to see how these commands
can be extended in order to also extrude the mesh):

@ftable @code
@item Extrude Point | Line | Surface @{ @var{expression}, @{ @var{expression-list} @} @};
Extrudes the @var{expression}-th point, line or surface using a translation
transformation. The @var{expression-list} should contain three
@w{@var{expression}s} giving the X, Y and Z components of the translation
vector.

@item Extrude Point | Line | Surface @{ @var{expression}, @{ @var{expression-list} @}, @{ @var{expression-list} @}, @var{expression} @};
Extrudes the @var{expression}-th point, line or surface using a rotation
transformation. The first @var{expression-list} should contain three
@w{@var{expression}s} giving the X, Y and Z direction of the rotation axis;
the second @var{expression-list} should contain three @w{@var{expression}s}
giving the X, Y and Z components of any point on this axis; the last
@var{expression} should contain the rotation angle (in radians).

@item Extrude Point | Line | Surface @{ @var{expression}, @{ @var{expression-list} @}, @{ @var{expression-list} @}, @{ @var{expression-list} @}, @var{expression} @};
Extrudes the @var{expression}-th point, line or surface using a translation
combined with a rotation. The first @var{expression-list} should contain
three @w{@var{expression}s} giving the X, Y and Z components of the
translation vector; the second @var{expression-list} should contain three
@w{@var{expression}s} giving the X, Y and Z direction of the rotation axis;
the third @var{expression-list} should contain three @w{@var{expression}s}
giving the X, Y and Z components of any point on this axis; the last
@var{expression} should contain the rotation angle (in radians).
@end ftable

@c .........................................................................
@c Transformations
@c .........................................................................

@node Transformations, Miscellaneous geometry commands, Extrusions, Geometry commands
@subsection Transformations

Geometrical transformations can be applied to elementary entities, or to
copies of geometrical entities (using the @code{Duplicata} command: see
below). The syntax of the transformation commands is:

@var{transform}:
@ftable @code
@item Dilate @{ @{ @var{expression-list} @}, @var{expression} @} @{ @var{transform-list} @}
Scales all elementary entities (points, lines or surfaces) in
@var{transform-list} by a factor @var{expression}. The @var{expression-list}
should contain three @w{@var{expression}s} giving the X, Y and Z direction
of the homothetic transformation.

@item Rotate @{ @{ @var{expression-list} @}, @{ @var{expression-list} @}, @var{expression} @}  @{ @var{transform-list} @}
Rotates all elementary entities (points, lines or surfaces) in
@var{transform-list} by an angle of @var{expression} radians. The first
@var{expression-list} should contain three @w{@var{expression}s} giving the
X, Y and Z direction of the rotation axis; the second @var{expression-list}
should contain three @w{@var{expression}s} giving the X, Y and Z components
of any point on this axis.

@item Symmetry @{ @var{expression-list} @} @{ @var{transform-list} @}
Transforms all elementary entities (points, lines or surfaces) by symmetry
in respect to a plane. The @var{expression-list} should contain four
@w{@var{expression}s} giving the coeffients of the plane's equation.

@item Translate @{ @var{expression-list} @} @{ @var{transform-list} @}
Translates all elementary entities (points, lines or surfaces) in
@var{transform-list}. The @var{expression-list} should contain three
@w{@var{expression}s} giving the X, Y and Z components of the translation
vector.
@end ftable

@noindent with

@example
@var{transform-list}: 
  < Point | Line | Surface @{ @var{expression-list} @}; > @dots{} |
  Duplicata @{ < Point | Line | Surface @{ @var{expression-list} @}; > @dots{} @} |
  @var{transform}
@end example

@c .........................................................................
@c Miscellaneous
@c .........................................................................

@node Miscellaneous geometry commands,  , Transformations, Geometry commands
@subsection Miscellaneous

Here is a list of all other geometry commands currently available:

@ftable @code
@item Coherence;
Removes all duplicate elementary geometrical entities (e.g. points having
identical coordinates). Note that Gmsh executes the @code{Coherence} command
automatically after each geometrical transformation, unless the
@code{Geometry.AutoCoherence} is set to zero (@pxref{Geometry options}).

@item Delete @{ < Point | Line | Surface @{ @var{expression-list} @}; > @dots{} @};
Deletes all elementary entities (points, lines or surfaces) whose numbers
are given in @var{expression-list}.

@c todo:
@c @item Intersect;
@c Intersects all lines.
@end ftable

@c -------------------------------------------------------------------------
@c Geometry options
@c -------------------------------------------------------------------------

@node Geometry options,  , Geometry commands, Geometry module
@section Geometry options

Geometry options control the behavior of geometry commands, as well as the
way geometrical entitities are handled in the graphical user interface. For
the signification of the `Saved in:' field in the following list, see
@ref{General options}.

@include opt_geometry.texi

@c =========================================================================
@c Mesh module
@c =========================================================================

@node Mesh module, Solver module, Geometry module, Top
@chapter Mesh module

@cindex Mesh
@cindex Module, Mesh

@menu
* Mesh commands::               
* Mesh options::                
@end menu

@c -------------------------------------------------------------------------
@c Mesh commands
@c -------------------------------------------------------------------------

@node Mesh commands, Mesh options, Mesh module, Mesh module
@section Mesh commands

The mesh module commands mostly permit to modify the characteristic lengths
and specify structured grid parameters. The actual mesh ``actions'' cannot
be specified in the input ASCII text input files: they have to be given
either in the GUI (using the Mesh->1D|2D|3D buttons; see @ref{Running Gmsh})
or on the command line (with the @code{-1}, @code{-2} or @code{-3} options;
see @ref{Running Gmsh} and @ref{Command-line options}).

@menu
* Characteristic lengths::      
* Structured grids::            
* Miscellaneous mesh commands::  
@end menu

@c .........................................................................
@c Characteristic lengths
@c .........................................................................

@node Characteristic lengths, Structured grids, Mesh commands, Mesh commands
@subsection Characteristic lengths

@ftable @code
@item Attractor Point @{ @var{expression-list} @} = @{ @var{expression}, @var{expression}, @var{expression} @};

(see @code{Mesh.Algorithm} in @ref{Mesh options}).

@item Attractor Line @{ @var{expression-list} @} = @{ @var{expression}, @var{expression}, @var{expression} @};

@item Characteristic Length @{ @var{expression-list} @} = @var{expression};

@end ftable

@c .........................................................................
@c Structured grids
@c .........................................................................

@node Structured grids, Miscellaneous mesh commands, Characteristic lengths, Mesh commands
@subsection Structured grids

@ftable @code
@item Bump

@item Elliptic

@item Extrude Layers          

@item Power           

@item Progression     

@item Parametric	

@item Transfinite     

@item With		

@item Using           

@item In              
@end ftable

@c .........................................................................
@c Miscellaneous
@c .........................................................................

@node Miscellaneous mesh commands,  , Structured grids, Mesh commands
@subsection Miscellaneous

Here is a list of all other mesh commands currently available:

@ftable @code
@item Color

@item Delete Meshes;
Deletes all currently loaded meshes.

@item Recombine

@end ftable

@c -------------------------------------------------------------------------
@c Mesh options
@c -------------------------------------------------------------------------

@node Mesh options,  , Mesh commands, Mesh module
@section Mesh options

@include opt_mesh.texi

@c =========================================================================
@c Solver module
@c =========================================================================

@node Solver module, Post-processing module, Mesh module, Top
@chapter Solver module

@cindex Solver
@cindex Module, Solver

No solver commands. The solver interface works like this XXX. Include C code
from solver example?

@c -------------------------------------------------------------------------
@c Solver options
@c -------------------------------------------------------------------------

@menu
* Solver options::              
@end menu

@node Solver options,  , Solver module, Solver module
@section Solver options

@include opt_solver.texi

@c =========================================================================
@c Post-processing module
@c =========================================================================

@node Post-processing module, Tutorial, Solver module, Top
@chapter Post-processing module

@cindex Post-processing
@cindex Module, Post-processing

@menu
* Post-processing commands::    
* Post-processing options::     
@end menu

@c -------------------------------------------------------------------------
@c Post-processing commands
@c -------------------------------------------------------------------------

@node Post-processing commands, Post-processing options, Post-processing module, Post-processing module
@section Post-processing commands

@ftable @code
@item ColorTable

@item Delete View[@var{expression}];
Deletes (removes) the @var{expression}-th post-processing view. View
numbers start at zero.

@item Duplicata View[@var{expression}];
Duplicates the @var{expression}-th post-processing view.

@item Plugin

@item View "@var{string}" @{ @var{string} ( @var{expression-list} ) @{ @var{expression-list} @}; @dots{} @}
Creates a new post-processig view, named @code{"@var{string}"}.

See @ref{Gmsh parsed post-processing file format}
@item SP
@item VP
@item TP

@item SL
@item VL
@item TL

@item ST
@item VT
@item TT

@item SQ
@item VQ
@item TQ

@item SS
@item VS
@item TS

@item SH
@item VH
@item TH

@item SI
@item VI
@item TI

@item SY
@item VY
@item TY

@item T2

@item T3
@end ftable

@c -------------------------------------------------------------------------
@c Post-processing options
@c -------------------------------------------------------------------------

@node Post-processing options,  , Post-processing commands, Post-processing module
@section Post-processing options

@include opt_post.texi

Options that should apply to all views are given by @code{View.Option}. To
set an option specifically for the n-th view, use @code{View[n].Option}
(view numbers start at zero).

@include opt_view.texi

@c =========================================================================
@c Tutorial
@c =========================================================================

@node Tutorial, Running Gmsh, Post-processing module, Top
@chapter Tutorial

@cindex Short examples
@cindex Examples
@cindex Tutorial

Here are the examples in the Gmsh tutorial. These examples are commented
(both C and C++-style comments can be used in Gmsh input files: see
@ref{Comments}) and should introduce new features gradually, starting with
@file{t1.geo}.

This tutorial does not explain the mesh and post-processing file
formats. See @ref{File formats} for this.

@menu
* t1.geo::                      
* t2.geo::                      
* t3.geo::                      
* t4.geo::                      
* t5.geo::                      
* t6.geo::                      
* t7.geo::                      
* t8.geo::                      
* t9.geo::                      
@end menu

@c -------------------------------------------------------------------------
@c t1.geo
@c -------------------------------------------------------------------------

@node t1.geo, t2.geo, Tutorial, Tutorial
@section @file{t1.geo}

@verbatiminclude ../../tutorial/t1.geo

@c -------------------------------------------------------------------------
@c t2.geo
@c -------------------------------------------------------------------------

@node t2.geo, t3.geo, t1.geo, Tutorial
@section @file{t2.geo}

@verbatiminclude ../../tutorial/t2.geo

@c -------------------------------------------------------------------------
@c t3.geo
@c -------------------------------------------------------------------------

@node t3.geo, t4.geo, t2.geo, Tutorial
@section @file{t3.geo}

@verbatiminclude ../../tutorial/t3.geo

@c -------------------------------------------------------------------------
@c t4.geo
@c -------------------------------------------------------------------------

@node t4.geo, t5.geo, t3.geo, Tutorial
@section @file{t4.geo}

@verbatiminclude ../../tutorial/t4.geo

@c -------------------------------------------------------------------------
@c t5.geo
@c -------------------------------------------------------------------------

@node t5.geo, t6.geo, t4.geo, Tutorial
@section @file{t5.geo}

@verbatiminclude ../../tutorial/t5.geo

@c -------------------------------------------------------------------------
@c t6.geo
@c -------------------------------------------------------------------------

@node t6.geo, t7.geo, t5.geo, Tutorial
@section @file{t6.geo}

@verbatiminclude ../../tutorial/t6.geo

@c -------------------------------------------------------------------------
@c t7.geo
@c -------------------------------------------------------------------------

@node t7.geo, t8.geo, t6.geo, Tutorial
@section @file{t7.geo}

@verbatiminclude ../../tutorial/t7.geo

@c -------------------------------------------------------------------------
@c t8.geo
@c -------------------------------------------------------------------------

@node t8.geo, t9.geo, t7.geo, Tutorial
@section @file{t8.geo}

@verbatiminclude ../../tutorial/t8.geo

@c -------------------------------------------------------------------------
@c t9.geo
@c -------------------------------------------------------------------------

@node t9.geo,  , t8.geo, Tutorial
@section @file{t9.geo}

@verbatiminclude ../../tutorial/t9.geo

@c =========================================================================
@c Running Gmsh
@c =========================================================================

@node Running Gmsh, File formats, Tutorial, Top
@chapter Running Gmsh

@cindex Operating system
@cindex Platforms
@cindex Command line options
@cindex Options, command line
@cindex Running Gmsh

@menu
* Interactive vs. non-interactive mode::  
* Command-line options::        
* Mouse actions::               
* Keyboard shortcuts::          
@end menu

@c -------------------------------------------------------------------------
@c Interactive vs. non-interactive mode
@c -------------------------------------------------------------------------

@node Interactive vs. non-interactive mode, Command-line options, Running Gmsh, Running Gmsh
@section Interactive vs. non-interactive mode

There are several different ways to actually run Gmsh on your
computer@footnote{Note that these operation modes can slightly vary
depending on the operating system and/or shell you use.} The first working
mode of Gmsh is the interactive graphical mode. To launch Gmsh in
interactive mode, just click or double-click on the Gmsh icon (Windows and
Mac), or type

@example
> gmsh
@end example

@noindent at your shell prompt on the command line (Unix). This will open
two windows: the graphic window (with a status bar at the bottom) and the
menu window (with a menu bar and some context dependent buttons). To open
the first tutorial file, select the `File->Open' menu, and choose
@file{t1.geo} in the input field. To perform the mesh generation, go to the
mesh module (by selecting `Mesh' in the module menu) and choose the required
dimension in the context-dependent buttons (`1D' will mesh all the lines;
`2D' will mesh all the surfaces---as well as all the lines if `1D' was not
called before; `3D' will mesh all the volumes---and all the surfaces if `2D'
was not called before). To save the resulting mesh in the current mesh
format, choose `Save' in the context-dependent buttons, or select the
appropriate format with the `File->Save as' menu. The default mesh file name
is based on the name of the first input file on the command line (or
@file{untitled} if there wasn't any input file given), with an appended
extension depending on the mesh format.

Note that nearly all the interactive commands have shortcuts: see
@ref{Keyboard shortcuts} or select `Help->Shortcuts' in the menu bar to
learn about these.

Instead of opening the tutorial with the `File->Open' menu, it is
often more convenient to put the file name on the command line, for
example with:

@example
> gmsh t1.geo
@end example

Note that, even if it is often handy to define the variables and the points
directly in the input files (you may use any text editor for this purpose,
e.g. Wordpad on Windows, or Emacs on Unix), it is almost always more simple
to define the lines, the surfaces and the volumes interactively. To do so,
just follow the context dependent buttons in the Geometry module. For
example, to create a spline, select `Geometry' in the module menu, and then
select `Elementary, Add, New, Spline'. You will then be asked (in the status
bar of the graphic window) to select a list of points, and to type @kbd{e} to
finish the selection (or @kbd{q} to abort it). Once the interactive command is
completed, a string is automatically added at the end of the currently
opened project file.

The second operating mode for Gmsh is the non-interactive mode. In this
mode, there is no graphical user interface, and all operations are performed
without any user interaction@footnote{If you compile Gmsh without the
graphical user interface, i.e. with @code{./configure --disable-gui}, this
is the only mode you;ll have access to.}. To mesh the first tutorial in
non-interactive mode, just type:

@example
> gmsh t1.geo -2
@end example

To mesh the same example, but with the background mesh available in the file
@file{bgmesh.pos}, just type:

@example
> gmsh t1.geo -2 -bgm bgmesh.pos
@end example

You should read the notes in the file @file{bgmesh.pos} if you intend to use
background meshes.

Several files can be loaded simultaneously in Gmsh. The first one defines
the project, while the others are appended ("merged") to this project. You
can merge such files with the `File->Merge' menu, or by directly specifying
the names of the files on the command line. This is most useful for
post-processing purposes. For example, to merge the post-processing views
contained in the files @file{view1.pos} and @file{view2.pos} together with
the first tutorial @file{t1.geo}, you can type the following command:

@example
> gmsh t1.geo view1.pos view2.pos
@end example

In the Post-Processing module (select `Post_Processing' in the module
menu), two view buttons will appear, respectively labeled "a scalar
map" and "a vector map". A mouse click on the name will toggle the
visibility of the selected view, while a click on the arrow button on
the right will provide access to the view's options. If you want the
modifications made to one view to affect also all the other views,
select the `Apply next changes to all views' or `Force same options
for all views' option in the `Tools->Options->Post-processing' menu.

Note that all the options specified interactively can also be directly
specified in the ASCII input files. All available options, with their
current values, can be saved into a file by selecting `File->Save as->Gmsh
options', or simply viewed by pressing the `?' button in the status bar. To
save the current options as your default preferences for all future Gmsh
sessions, use the `Tools->Options->Save' button.

@c -------------------------------------------------------------------------
@c Command-line options
@c -------------------------------------------------------------------------

@node Command-line options, Mouse actions, Interactive vs. non-interactive mode, Running Gmsh
@section Command-line options

@include command_line.texi

@c -------------------------------------------------------------------------
@c Mouse actions
@c -------------------------------------------------------------------------

@node Mouse actions, Keyboard shortcuts, Command-line options, Running Gmsh
@section Mouse actions

In the following, for a 2 button mouse, @kbd{Middle button} =
@kbd{Shift+Left button}. For a 1 button mouse, @kbd{Middle button} =
@kbd{Shift+Left button} and @kbd{Right button} = @kbd{Alt+Left button}.


@kbd{Move the mouse}:
@itemize @bullet
@item
highlight the elementary geometrical entity currently under the mouse
pointer and display its properties in the status bar
@item
size a rubber zoom started with @kbd{Ctrl+Left button}
@end itemize

@kbd{Left button}:
@itemize @bullet
@item
rotate
@item
accept a rubber zoom started with @kbd{Ctrl+Left button}
@end itemize

@kbd{Ctrl+Left button}: start (anisotropic) rubber zoom

@kbd{Middle button}:
@itemize @bullet
@item
zoom (isotropic)
@item
cancel a rubber zoom
@end itemize

@kbd{Ctrl+Middle button}: orthogonalize display

@kbd{Right button}:
@itemize @bullet
@item
pan
@item
cancel a rubber zoom
@item
pop up menu on post-processing view button
@end itemize

@kbd{Ctrl+Right button}: reset to default viewpoint

@c -------------------------------------------------------------------------
@c Keyboard shortcuts
@c -------------------------------------------------------------------------

@node Keyboard shortcuts,  , Mouse actions, Running Gmsh
@section Keyboard shortcuts

@include shortcuts.texi

@c =========================================================================
@c File Formats
@c =========================================================================

@node File formats, Programming notes, Running Gmsh, Top
@chapter File formats

@cindex File formats

This chapter describes the file formats that cannot be modified by the
user. These format have a version number (currently 1.2), independent of the
Gmsh version number (currently @value{GMSH-VERSION}).

All non-parsed file formats have sections enclosed between @code{$KEY} and
@code{$ENDKEY} symbol pairs.

@menu
* Gmsh mesh file format::       
* Gmsh ASCII post-processing file format::  
* Gmsh binary post-processing file format::  
* Gmsh parsed post-processing file format::  
* Gmsh node ordering::          
@end menu

@c -------------------------------------------------------------------------
@c Gmsh mesh file format
@c -------------------------------------------------------------------------

@node Gmsh mesh file format, Gmsh ASCII post-processing file format, File formats, File formats
@section Gmsh mesh file format

@cindex Mesh, file format
@cindex @file{.msh} file

The @file{.msh} file format is Gmsh's native mesh file format. The file is
divided into two sections, defining the nodes (@code{NOD}-@code{ENDNOD}) and
the elements (@code{ELM}-@code{ENDELM}) in the mesh:

@example
$NOD
@var{number-of-nodes}
@var{node-number} @var{x-coord} @var{y-coord} @var{z-coord}
@dots{}
$ENDNOD
$ELM
@var{number-of-elements}
@var{elm-number} @var{elm-type} @var{reg-phys} @var{reg-elemem} @var{number-of-nodes} @var{node-number-list}
@dots{}
$ENDELM
@end example

@noindent
where
@table @code
@item @var{number-of-nodes}
is the number of nodes in the mesh

@item @var{node-number}
is the number (index) of the n-th node in the mesh. Note that the
@w{@var{node-number}s} should not necessarily given in a consecutive (or
even an ordered) way.

@item @var{x-coord}
@item @var{y-coord}
@item @var{z-coord}
are the floating point values giving the X, Y and Z coordinate of the n-th
node.

@item @var{number-of-elements}
is the number of elements in the mesh

@item @var{elm-number}
is the number (index) of the n-th element in the mesh. Note that the
@w{@var{elm-number}s} should not necessarily given in a consecutive (or even
an ordered) way.

@item @var{elm-type}
defines the geometrical type for the n-th element:
@table @code
@item 1
Line (2 nodes, 1 edge).
@item 2
Triangle (3 nodes, 3 edges).
@item 3
Quadrangle (4 nodes, 4 edges).
@item 4
Tetrahedron (4 nodes, 6 edges, 4 facets).
@item 5
Hexahedron (8 nodes, 12 edges, 6 facets).
@item 6
Prism (6 nodes, 9 edges, 5 facets).
@item 7
Pyramid (5 nodes, 8 edges, 5 facets).
@item 15
Point (1 node).
@end table

@item @var{reg-phys}
is the number of the physical entity to which the element belongs. 

@item @var{reg-elem}
is the number of the elementary entity to which the element belongs.

@item @var{number-of-nodes}
is the number of nodes for the n-th element. This is redundant, but kept for
backward compatibility reasons. The redundancy may disappear in the future
if higher order elements are implemented using the same @w{@var{elm-type}s}
as the current ones.

@item @var{node-number-list}
is a list of @var{number-of-nodes} node numbers (separated by white space,
without commas).
@end table

@c -------------------------------------------------------------------------
@c Gmsh ASCII post-processing file format
@c -------------------------------------------------------------------------

@node Gmsh ASCII post-processing file format, Gmsh binary post-processing file format, Gmsh mesh file format, File formats
@section Gmsh ASCII post-processing file format

@cindex Post-processing, ASCII file format
@cindex @file{.pos} file

The ASCII post-processing file is divided in several sections: one format
section, enclosed between @code{$PostFormat}-@code{$EndPostFormat}, and one
or more post-processing views, enclosed between @code{$View}-@code{$EndView}
tags:

@example
$PostFormat
1.2 @var{file-type} @var{data-size}
$EndPostFormat
$View
@var{view-name} @var{nb-time-steps}
@var{nb-scalar-points} @var{nb-vector-points} @var{nb-tensor-points}
@var{nb-scalar-lines} @var{nb-vector-lines} @var{nb-tensor-lines}
@var{nb-scalar-triangles} @var{nb-vector-triangles} @var{nb-tensor-triangles}
@var{nb-scalar-quadrangles} @var{nb-vector-quadrangles} @var{nb-tensor-quadrangles}
@var{nb-scalar-tetrahedra} @var{nb-vector-tetrahedra} @var{nb-tensor-tetrahedra}
@var{nb-scalar-hexahedra} @var{nb-vector-hexahedra} @var{nb-tensor-hexahedra}
@var{nb-scalar-prisms} @var{nb-vector-prisms} @var{nb-tensor-prisms}
@var{nb-scalar-pyramids} @var{nb-vector-pyramids} @var{nb-tensor-pyramids}
@var{nb-text2d} @var{nb-text2d-chars} @var{nb-text3d} @var{nb-text3d-chars}
@var{time-step-values}
< @var{scalar-point-value} > @dots{}
< @var{vector-point-value} > @dots{}
< @var{tensor-point-value} > @dots{}
< @var{scalar-line-value} > @dots{}
< @var{vector-line-value} > @dots{}
< @var{tensor-line-value} > @dots{}
< @var{scalar-triangle-value} > @dots{}
< @var{vector-triangle-value} > @dots{}
< @var{tensor-triangle-value} > @dots{}
< @var{scalar-quadrangle-value} > @dots{}
< @var{vector-quadrangle-value} > @dots{}
< @var{tensor-quadrangle-value} > @dots{}
< @var{scalar-tetrahedron-value} > @dots{}
< @var{vector-tetrahedron-value} > @dots{}
< @var{tensor-tetrahedron-value} > @dots{}
< @var{scalar-hexahedron-value} > @dots{}
< @var{vector-hexahedron-value} > @dots{}
< @var{tensor-hexahedron-value} > @dots{}
< @var{scalar-prism-value} > @dots{}
< @var{vector-prism-value} > @dots{}
< @var{tensor-prism-value} > @dots{}
< @var{scalar-pyramid-value} > @dots{}
< @var{vector-pyramid-value} > @dots{}
< @var{tensor-pyramid-value} > @dots{}
< @var{text2d} > @dots{} < @var{text2d-chars} > @dots{}
< @var{text3d} > @dots{} < @var{text3d-chars} > @dots{}
$EndView
@end example

@noindent
where
@table @code
@item @var{file-type}
is an integer equal to 0 in the ASCII file format.

@item @var{data-size}
is an integer equal to the size of the floating point numbers used in the
file (usually, data-size == sizeof(double)).

@item @var{view-name}
is a string containing the name of the view (max. 256 characters)

@item @var{nb-time-step}
is an integer giving the number of time steps in the view

@item @var{nb-scalar-points}
@item @var{nb-vector-points}
@item @dots{}
are integers giving the number of scalar points, vector points,@w{ }@dots{}
in the view.

@item @var{nb-text2d}
@item @var{nb-text3d}
are integers giving the number of 2D and 3D text strings in the
view. 

@item @var{nb-text2d-chars}
@item @var{nb-text3d-chars}
are integers giving the total number of characters in the 2D and 3D strings.

@item @var{time-step-values}
is a list of nb-time-steps double precision numbers giving the value of the
time (or any other variable) for which an evolution was saved.

@item @var{scalar-point-value}
@item @var{vector-point-value}
@item @dots{}
are lists of double precision numbers giving the node coordinates and the
values associated with the nodes of the @var{nb-scalar-points} scalar
points, @var{nb-vector-points} vector points,@w{ }@dots{}, for each of the
@var{time-step-values}.

For example, @var{vector-triangle-value} is defined as:
@example
@var{coord1-node1} @var{coord1-node2} @var{coord1-node3}
@var{coord2-node1} @var{coord2-node2} @var{coord2-node3}
@var{coord3-node1} @var{coord3-node2} @var{coord3-node3}
@var{comp1-node1-time1} @var{comp2-node1-time1} @var{comp3-node1-time1}
@var{comp1-node2-time1} @var{comp2-node2-time1} @var{comp3-node2-time1}
@var{comp1-node3-time1} @var{comp2-node3-time1} @var{comp3-node3-time1}
@var{comp1-node1-time2} @var{comp2-node1-time2} @var{comp3-node1-time2}
@var{comp1-node2-time2} @var{comp2-node2-time2} @var{comp3-node2-time2}
@var{comp1-node3-time2} @var{comp2-node3-time2} @var{comp3-node3-time2}
@dots{}
@end example

@item @var{text2d}
is a list of 4 double precision numbers:
@example
@var{coord1} @var{coord2} @var{style} @var{index}
@end example
where @var{coord1} and @var{coord2} give the coordinates of the leftmost
element of the 2D string in screen coordinates, @var{index} gives the
starting index of the string in @var{text2d-chars} and @var{style} is
currently unused.

@item @var{text2d-chars}
is a list of @item @var{nb-text2d-chars} characters. Substrings are
separated with the @code{^} character (which is a forbidden character in
regular strings).

@item @var{text3d}
is a list of 5 double precision numbers
@example
@var{coord1} @var{coord2} @var{coord3} @var{style} @var{index}
@end example
where @var{coord1}, @var{coord2} and @var{coord3} give the coordinates of
the leftmost element of the 3D string in model (real world) coordinates,
@var{index} gives the starting index of the string in @var{text3d-chars} and
@var{style} is currently unused.

@item @var{text3d-chars}
is a list of @var{nb-text3d-chars} chars. Substrings are separated with the
@code{^} characted.
@end table

@c -------------------------------------------------------------------------
@c Gmsh binary post-processing file format
@c -------------------------------------------------------------------------

@node Gmsh binary post-processing file format, Gmsh parsed post-processing file format, Gmsh ASCII post-processing file format, File formats
@section Gmsh binary post-processing file format

@cindex Post-processing, binary file format
@cindex @file{.pos} file

The binary post-processing file format is the same as the ASCII file format
described in @ref{Gmsh ASCII post-processing file format}, except that:

@enumerate
@item
@var{file-type} equals 1.
@item 
all lists of floating point numbers and characters are written in binary
format
@item
there is an additional integer, of value 1, written before
time-step-values. This integer is used for detecting if the computer on
which the binary file was written and the computer on which the file is read
are of the same type (little or big endian).
@end enumerate

Here is a pseudo C code to write the beginning of a post-processing
file in binary format:

@example
int one = 1;

fprintf(file, "$PostFormat\n");
fprintf(file, "%g %d %d\n", 1.2, 1, sizeof(double));
fprintf(file, "$EndPostFormat\n");
fprintf(file, "$View\n");
fprintf(file, "%s %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d "
  "%d %d %d %d\n", 
  view-name, nb-time-steps,
  nb-scalar-points, nb-vector-points, nb-tensor-points,
  nb-scalar-lines, nb-vector-lines, nb-tensor-lines,
  nb-scalar-triangles, nb-vector-triangles, nb-tensor-triangles,
  nb-scalar-quadrangles, nb-vector-quadrangles, nb-tensor-quadrangles,
  nb-scalar-tetrahedra, nb-vector-tetrahedra, nb-tensor-tetrahedra,
  nb-scalar-hexahedra, nb-vector-hexahedra, nb-tensor-hexahedra,
  nb-scalar-prisms, nb-vector-prisms, nb-tensor-prisms,
  nb-scalar-pyramids, nb-vector-pyramids, nb-tensor-pyramids,
  nb-text2d, nb-text2d-chars, nb-text3d, nb-text3d-chars);
fwrite(&one, sizeof(int), 1, file);
fwrite(time-step-values, sizeof(double), nb-time-steps, file);
fwrite(all-scalar-point-values, sizeof(double), ..., file);
...
fprintf(file, "\n$EndView\n");
@end example
In this pseudo-code, @var{all-scalar-point-values} is the array of double
precision numbers containing all the @var{scalar-point-value} lists, put one
after each other in order to form a long array of doubles. The principle is
the same for all other kinds of values.

@c -------------------------------------------------------------------------
@c Gmsh parsed post-processing file format
@c -------------------------------------------------------------------------

@node Gmsh parsed post-processing file format, Gmsh node ordering, Gmsh binary post-processing file format, File formats
@section Gmsh parsed post-processing file format

@cindex Post-processing, parsed file format
@cindex @file{.pos} file

For relatively small data sets Gmsh provides an additional post-processing
format, which is parsed by the same grammar analyzer as the Gmsh script
language. You can thus, for example, embed small post-processing views
directly into your geometrical descriptions (see e.g. @ref{t4.geo}). This
format is also useful for testing purposes: its syntax is very permissive,
and you can easily generate it by hand or on the fly. The format of the
parsed post-processing file is the following:

@example
View "@var{string}" @{
  @var{type} ( @var{list-of-coords} ) @{ @var{list-of-values} @};
  @dots{}
@};
@end example

The same 26 base objects can be displayed as in the ASCII or binary
post-processing file formats:

@example
                    @var{type}  #@var{list-of-coords}  #@var{list-of-values}
------------------------------------------------------------
scalar point        SP    3            1  * @var{nb-time-step}
vector point        VP    3            3  * @var{nb-time-step}
tensor point        TP    3            9  * @var{nb-time-step}
scalar line         SL    6            2  * @var{nb-time-step}
vector line         VL    6            6  * @var{nb-time-step}
tensor line         TL    6            18 * @var{nb-time-step}
scalar triangle     ST    9            3  * @var{nb-time-step}
vector triangle     VT    9            9  * @var{nb-time-step}
tensor triangle     TT    9            27 * @var{nb-time-step}
scalar quadrangle   SQ    12           4  * @var{nb-time-step}
vector quadrangle   VQ    12           12 * @var{nb-time-step}
tensor quadrangle   TQ    12           36 * @var{nb-time-step}
scalar tetrahedron  SS    12           4  * @var{nb-time-step}
vector tetrahedron  VS    12           12 * @var{nb-time-step}
tensor tetrahedron  TS    12           36 * @var{nb-time-step}
scalar hexahedron   SH    24           8  * @var{nb-time-step}
vector hexahedron   VH    24           24 * @var{nb-time-step}
tensor hexahedron   TH    24           72 * @var{nb-time-step}
scalar prism        SI    18           6  * @var{nb-time-step}
vector prism        VI    18           18 * @var{nb-time-step}
tensor prism        TI    18           54 * @var{nb-time-step}
scalar pyramid      SY    15           5  * @var{nb-time-step}
vector pyramid      VY    15           15 * @var{nb-time-step}
tensor pyramid      TY    15           45 * @var{nb-time-step}
text 2d             T2    4            arbitrary
text 3d             T3    5            arbitrary
@end example

But, for historical reasons, contrary to the ASCII and binary
post-processing file formats, the coordinates are given by node, i.e.:

@itemize @bullet
@item
@code{(coord1, coord2,coord3)} for a point,
@item 
@code{(coord1-node1, coord2-node1, coord3-node1,}@* 
@code{ coord1-node2, coord2-node2, coord3-node2)} for a line,
@item 
@code{(coord1-node1, coord2-node1, coord3-node1,}@*
@code{ coord1-node2, coord2-node2, coord3-node2,}@*
@code{ coord1-node3, coord2-node3, coord3-node3)} for a triangle,
@item
etc.
@end itemize
The values are given in the same order as for the ASCII and binary
post-processing file formats.

@c -------------------------------------------------------------------------
@c Gmsh node ordering
@c -------------------------------------------------------------------------

@node Gmsh node ordering,  , Gmsh parsed post-processing file format, File formats
@section Gmsh node ordering

For all mesh and post-processing file formats, the reference elements are
defined as follows.

Point:
@example
        v                            
        |                            
        |                            
   -----1-----u  
        |                            
        |                            
@end example

Line:
@example
                  edge 1: nodes 1 -> 2  
        v                            
        |                            
        |                            
   --1-----2--u  
        |                            
        |                            
@end example

Triangle:
@example
                  edge 1: nodes 1 -> 2         
   v                   2:       1 -> 3                  
   |                   3:       2 -> 3                  
   |                           
   3              face 1: edges 1 -2 3   nodes 1 2 3
   |\        
   | \       
   |__\___u                    
   1   2                       

@end example

Quadrangle:
@example
                  edge 1: nodes 1 -> 2 
        v              2:       1 -> 4                    
        |              3:       2 -> 3                    
     4--|--3           4:       3 -> 4 
     |  |  |     
   -----------u   face 1: edges 1 -2 3 4   nodes 1 2 3 4
     |  |  |     
     1--|--2      
        |         

@end example

Tetrahedron:
@example
                  edge 1: nodes 1 -> 2                
   v                   2:       1 -> 3                                            
   |                   3:       1 -> 4                
   |                   4:       2 -> 3                
   |                   5:       2 -> 4                
   3                   6:       3 -> 4                
   |\                                                 
   | \            face 1: edges  1 -3  5  nodes 1 2 4
   |__\2_____u         2:       -1  2 -4        1 3 2
   1\ /                3:       -2  3 -6        1 4 3
     \4                4:        4 -5  6        2 3 4
      \          
       w         
@end example

Hexahedron
@example
                  edge 1: nodes 1 -> 2
        v              2:       1 -> 4
        |              3:       1 -> 5
        |              4:       2 -> 3
   4----|--3           5:       2 -> 6
   |\   |  |\          6:       3 -> 4
   | 8-------7         7:       3 -> 7
   | |   ----|---u     8:       4 -> 8
   1-|---\-2 |         9:       5 -> 6
    \|    \ \|        10:       5 -> 8
     5-----\-6        11:       6 -> 7
            \         12:       7 -> 8
             w         
                  face 1: edges  1 -3  5 -9    nodes 1 2 6 5
                       2:       -1  2 -4 -6          1 4 3 2  
                       3:       -2  3 -8  10         1 5 8 4
                       4:        4 -5  7 -11         2 3 7 6
                       5:        6 -7  8 -12         3 4 8 7
                       6:        9 -10 11 12         5 6 7 8

@end example

Prism:
@example
                  edge 1: nodes 1 -> 2
      v                2:       1 -> 3
    3 |                3:       1 -> 4
    |\|                4:       2 -> 3
    | |                5:       2 -> 5
    1_|2               6:       3 -> 6
     \| 6              7:       4 -> 5
      |_|_\___u        8:       4 -> 6 
       \|  \           9:       5 -> 6 
        4 __5
         \        face 1: edges  1 -3  5 -7     nodes 1 2 5 4 
          \            2:       -1  2 -4              1 3 2   
           w           3:       -2  3 -6  8           1 4 6 3 
                       4:        4 -5  6 -9           2 3 6 5 
                       5:        7 -8  9              4 5 6   
@end example

Pyramid:
@example
                  edge 1: nodes 1 -> 2
        v              2:       1 -> 4 
        |              3:       1 -> 5
        |              4:       2 -> 3
    4---|---3          5:       2 -> 5
    | \ |  /|          6:       3 -> 4
    |  \ -/-|---u      7:       3 -> 5
    |  / 5\ |          8:       4 -> 5
    1/----\-2              
           \     facet 1: edges  1  5 -3       nodes 1 2 5  
            \          2:        2 -6 -4 -1          1 4 3 2
             w         3:        3 -8 -2             1 5 4  
                       4:        4  7 -5             2 3 5  
                       5:        6  8 -7             3 4 5  
 @end example

@c =========================================================================
@c Programming notes
@c =========================================================================

@node Programming notes, Bugs and versions, File formats, Top
@chapter Programming notes

@cindex Programming comments
@cindex Language
@cindex C
@cindex C++
@cindex @code{lex}
@cindex @code{flex}
@cindex @code{yacc}
@cindex @code{bison}

This is section is not yet written: see @file{utils/README.devel}.

@c The code itself is in C++, but most of it was initially written in C (hence
@c the hybrid code style...). The analysis of the syntax is performed by Lex
@c and Yacc.

@c All graphics are rendered using OpenGL (@uref{http://www.opengl.org}). A
@c free replacement for OpenGL can be found at @uref{http://www.mesa3d.org}.

@c The user interface is based on the FLTK widget set
@c (@uref{http://www.fltk.org}).

@c Build system based on autoconf. Should we add a chapter/section on how to
@c compile Gmsh? Compiling the Windows version requires the Cygwin tools
@c (freely available from @uref{http://www.cygwin.com}).


@c =========================================================================
@c Bugs, versions and contributors
@c =========================================================================

@ifclear COMMERCIAL

@node Bugs and versions, Tips and tricks, Programming notes, Top
@chapter Bugs, versions and contributors

@menu
* Bugs::                        
* Version history::             
* Contributors::                
@end menu

@c -------------------------------------------------------------------------
@c Bugs
@c -------------------------------------------------------------------------

@node Bugs, Version history, Bugs and versions, Bugs and versions
@section Bugs

@cindex Known bugs
@cindex Bugs, known
@cindex Bugs, reporting
@cindex Reporting bugs
@cindex Authors, e-mail
@cindex E-mail, authors

If you think you have found a bug in Gmsh, you can report it by electronic
mail to the Gmsh mailing list at @email{gmsh@@geuz.org}.  Please send as
precise a description of the problem as you can, including sample input
files that produce the bug (problem definition and mesh files). Don't forget
to mention both the version of Gmsh and the version of your operation
system (@pxref{Running Gmsh} to see how to get this information).

See the @file{TODO} file in the distribution to check the problems we
already know about.

@c -------------------------------------------------------------------------
@c Versions
@c -------------------------------------------------------------------------

@node Version history, Contributors, Bugs, Bugs and versions
@section Version history

@cindex Versions
@cindex History, versions
@cindex Changelog

@verbatiminclude ../VERSIONS

@c -------------------------------------------------------------------------
@c Contributors
@c -------------------------------------------------------------------------

@node Contributors,  , Version history, Bugs and versions
@section Contributors

@cindex Acknowledgments
@cindex Contributors, list
@cindex Credits 

@verbatiminclude ../CONTRIBUTORS

@end ifclear

@c =========================================================================
@c Tips ans Tricks
@c =========================================================================

@node Tips and tricks, GNU General Public License, Bugs and versions, Top
@appendix Tips and tricks

@cindex Tips
@cindex Tricks
@cindex Efficiency, tips

@itemize @bullet
@item
Install the `info' version of this user's guide! On your (Unix) system, this
can be achieved by 1) copying all gmsh.info* files to the place where your
info files live (usually /usr/info), and 2) issuing the command
`install-info /usr/info/gmsh.info /usr/info/dir'. You will then be able to
access the documentation with the command `info gmsh'. Note that particular
sections ("nodes") can be accessed directly. For example, `info gmsh
surfaces' or `info gmsh surf' will take you directly to @ref{Surfaces}.
@item
Use emacs to edit your files, and load the C++ mode! This permits automatic
syntax highlighting and easy indentation. Automatic loading of the C++ mode
for @file{.geo} files can be achieved by adding the following command in
your @code{.emacs} file: @code{(setq auto-mode-alist (append '(("\\.geo$"
. c++-mode)) auto-mode-alist))}.
@item
Define common geometrical objects and options in separate files, reusable in
all your problem definition structures.
@item
Save your preferred options with `Tools->Options->Save'. To reset default
options, erase the @code{General.OptionsFileName} (usually
@file{.gmsh-options} in your home directory) or use the `Restore default
options' button in `Tools->Options->General->Output'.
@item
Read the @file{FAQ}...
@end itemize

@c =========================================================================
@c GNU GPL
@c =========================================================================

@ifclear COMMERCIAL

@node  GNU General Public License, Concept index, Tips and tricks, Top
@appendix GNU General Public License

@include gpl.texi

@end ifclear

@c =========================================================================
@c Concept Index (cindex)
@c =========================================================================

@node Concept index, Syntax index, GNU General Public License, Top
@unnumbered Concept index

@cindex Index, concepts
@cindex Concepts, index

@printindex cp

@c =========================================================================
@c Syntax Index (tindex+findex)
@c =========================================================================

@node Syntax index,  , Concept index, Top
@unnumbered Syntax index

@cindex Index, syntax
@cindex Syntax, index
@cindex Keywords, index

@printindex tp

@bye
